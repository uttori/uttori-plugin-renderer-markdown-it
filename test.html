<p><nav class="table-of-contents"><ul><li><a href="#internal-registers-2" title="Internal Registers">Internal Registers</a></li><ul><li><a href="#flags-stored-in-p-register-15" title="Flags stored in P Register">Flags stored in P Register</a></li></ul><li><a href="#addressing-modes-30" title="Addressing Modes">Addressing Modes</a></li><li><a href="#instructions-61" title="Instructions">Instructions</a></li><ul><li><a href="#instruction-usage-353" title="Instruction Usage">Instruction Usage</a></li><ul><li><a href="#adc-add-with-carry-355" title="ADC - Add with carry">ADC - Add with carry</a></li><li><a href="#and-perform-and-to-accumulator-361" title="AND - Perform AND to Accumulator">AND - Perform AND to Accumulator</a></li><li><a href="#asl-left-shifts-accumulator-memory-367" title="ASL - Left shifts Accumulator, Memory">ASL - Left shifts Accumulator, Memory</a></li><li><a href="#bcc-branch-if-carry-clear-373" title="BCC - Branch if carry clear">BCC - Branch if carry clear</a></li><li><a href="#bcs-branch-if-carry-set-380" title="BCS - Branch if carry set">BCS - Branch if carry set</a></li><li><a href="#beq-branch-if-equal-383" title="BEQ - Branch if equal">BEQ - Branch if equal</a></li><li><a href="#bit-bit-test-392" title="BIT - Bit Test">BIT - Bit Test</a></li><li><a href="#bmi-branch-if-minus-398" title="BMI - Branch if Minus">BMI - Branch if Minus</a></li><li><a href="#bne-branch-if-not-equal-401" title="BNE - Branch if not equal">BNE - Branch if not equal</a></li><li><a href="#bpl-branch-if-plus-404" title="BPL - Branch if plus">BPL - Branch if plus</a></li><li><a href="#bra-branch-always-407" title="BRA - Branch always">BRA - Branch always</a></li><li><a href="#brk-break-to-instruction-410" title="BRK - Break to instruction">BRK - Break to instruction</a></li><li><a href="#brl-branch-relative-long-413" title="BRL - Branch Relative Long">BRL - Branch Relative Long</a></li><li><a href="#bvc-branch-if-overflow-clear-416" title="BVC - Branch if Overflow Clear">BVC - Branch if Overflow Clear</a></li><li><a href="#bvs-branch-if-overflow-set-419" title="BVS - Branch if Overflow Set">BVS - Branch if Overflow Set</a></li><li><a href="#clc-clear-carry-flag-422" title="CLC - Clear Carry Flag">CLC - Clear Carry Flag</a></li><li><a href="#cld-clear-decimal-flag-425" title="CLD - Clear Decimal Flag">CLD - Clear Decimal Flag</a></li><li><a href="#cli-clear-interrupt-flag-428" title="CLI - Clear Interrupt Flag">CLI - Clear Interrupt Flag</a></li><li><a href="#clv-clear-overflow-flag-431" title="CLV - Clear Overflow Flag">CLV - Clear Overflow Flag</a></li><li><a href="#cmp-compare-accumulator-with-memory-434" title="CMP - Compare Accumulator with memory">CMP - Compare Accumulator with memory</a></li><li><a href="#cpx-compare-x-with-memory-435" title="CPX - Compare X with memory">CPX - Compare X with memory</a></li><li><a href="#cpy-compare-y-with-memory-436" title="CPY - Compare Y with memory">CPY - Compare Y with memory</a></li><li><a href="#cop-coprocessor-empowerment-442" title="COP - Coprocessor Empowerment">COP - Coprocessor Empowerment</a></li><li><a href="#dec-decrement-accumulator-445" title="DEC - Decrement Accumulator">DEC - Decrement Accumulator</a></li><li><a href="#dex-decrement-x-446" title="DEX - Decrement X">DEX - Decrement X</a></li><li><a href="#dey-decrement-y-447" title="DEY - Decrement Y">DEY - Decrement Y</a></li><li><a href="#eor-exclusive-or-accumulator-453" title="EOR - Exclusive OR accumulator">EOR - Exclusive OR accumulator</a></li><li><a href="#inc-increment-accumulator-459" title="INC - Increment Accumulator">INC - Increment Accumulator</a></li><li><a href="#inx-increment-x-460" title="INX - Increment X">INX - Increment X</a></li><li><a href="#iny-increment-y-461" title="INY - Increment Y">INY - Increment Y</a></li><li><a href="#jmp-jump-to-location-467" title="JMP - Jump to location">JMP - Jump to location</a></li><li><a href="#jml-jump-long-468" title="JML - Jump long">JML - Jump long</a></li><li><a href="#jsr-jump-subroutine-475" title="JSR - Jump Subroutine">JSR - Jump Subroutine</a></li><li><a href="#jsl-jump-subroutine-long-476" title="JSL - Jump Subroutine Long">JSL - Jump Subroutine Long</a></li><li><a href="#lda-load-accumulator-with-memory-479" title="LDA - Load Accumulator with memory">LDA - Load Accumulator with memory</a></li><li><a href="#ldx-load-x-with-memory-480" title="LDX - Load X with memory">LDX - Load X with memory</a></li><li><a href="#ldy-load-y-with-memory-481" title="LDY - Load Y with memory">LDY - Load Y with memory</a></li><li><a href="#lsr-shift-right-accumulator-memory-484" title="LSR - Shift Right Accumulator, Memory">LSR - Shift Right Accumulator, Memory</a></li><li><a href="#mvn-block-move-negative-490" title="MVN - Block move negative">MVN - Block move negative</a></li><li><a href="#mvp-block-move-positive-491" title="MVP - Block move positive">MVP - Block move positive</a></li><li><a href="#nop-no-operation-518" title="NOP - No operation">NOP - No operation</a></li><li><a href="#ora-or-accumulator-with-memory-521" title="ORA - OR Accumulator with memory">ORA - OR Accumulator with memory</a></li><li><a href="#pea-push-effective-address-527" title="PEA - Push Effective Address">PEA - Push Effective Address</a></li><li><a href="#pei-push-effective-indirect-address-533" title="PEI - Push Effective Indirect Address">PEI - Push Effective Indirect Address</a></li><li><a href="#per-push-program-counter-relative-542" title="PER - Push Program Counter Relative">PER - Push Program Counter Relative</a></li><li><a href="#pha-push-accumulator-545" title="PHA - Push Accumulator">PHA - Push Accumulator</a></li><li><a href="#phd-push-direct-page-register-546" title="PHD - Push Direct Page Register">PHD - Push Direct Page Register</a></li><li><a href="#phk-push-program-bank-547" title="PHK - Push Program Bank">PHK - Push Program Bank</a></li><li><a href="#phx-push-x-548" title="PHX - Push X">PHX - Push X</a></li><li><a href="#phy-push-y-549" title="PHY - Push Y">PHY - Push Y</a></li><li><a href="#pla-pull-accumulator-552" title="PLA - Pull Accumulator">PLA - Pull Accumulator</a></li><li><a href="#pld-pull-direct-page-register-553" title="PLD - Pull Direct Page Register">PLD - Pull Direct Page Register</a></li><li><a href="#plp-pull-flags-554" title="PLP - Pull Flags">PLP - Pull Flags</a></li><li><a href="#plx-pull-x-555" title="PLX - Pull X">PLX - Pull X</a></li><li><a href="#ply-pull-y-556" title="PLY - Pull Y">PLY - Pull Y</a></li><li><a href="#rep-reset-flag-559" title="REP - Reset Flag">REP - Reset Flag</a></li><li><a href="#rol-rotate-bit-left-564" title="ROL - Rotate Bit Left">ROL - Rotate Bit Left</a></li><li><a href="#ror-rotate-bit-right-570" title="ROR - Rotate Bit Right">ROR - Rotate Bit Right</a></li><li><a href="#rti-return-from-interrupt-576" title="RTI - Return from Interrupt">RTI - Return from Interrupt</a></li><li><a href="#rts-return-from-subroutine-579" title="RTS - Return from Subroutine">RTS - Return from Subroutine</a></li><li><a href="#rtl-return-from-subroutine-long-580" title="RTL - Return from Subroutine Long">RTL - Return from Subroutine Long</a></li><li><a href="#sbc-subtract-with-carry-591" title="SBC - Subtract with Carry">SBC - Subtract with Carry</a></li><li><a href="#sec-set-carry-flag-594" title="SEC - Set Carry Flag">SEC - Set Carry Flag</a></li><li><a href="#sed-set-decimal-flag-597" title="SED - Set Decimal Flag">SED - Set Decimal Flag</a></li><li><a href="#sei-set-interrupt-flag-600" title="SEI - Set Interrupt Flag">SEI - Set Interrupt Flag</a></li><li><a href="#sep-set-flag-603" title="SEP - Set Flag">SEP - Set Flag</a></li><li><a href="#sta-store-accumulator-to-memory-608" title="STA - Store Accumulator to memory">STA - Store Accumulator to memory</a></li><li><a href="#stx-store-x-to-memory-609" title="STX - Store X to memory">STX - Store X to memory</a></li><li><a href="#sty-store-y-to-memory-610" title="STY - Store Y to memory">STY - Store Y to memory</a></li><li><a href="#stp-stop-the-clock-616" title="STP - Stop the clock">STP - Stop the clock</a></li><li><a href="#stz-store-zero-to-memory-619" title="STZ - Store zero to memory">STZ - Store zero to memory</a></li><li><a href="#tax-transfer-accumulator-to-x-624" title="TAX - Transfer Accumulator to X">TAX - Transfer Accumulator to X</a></li><li><a href="#tay-transfer-accumulator-to-y-625" title="TAY - Transfer Accumulator to Y">TAY - Transfer Accumulator to Y</a></li><li><a href="#tcd-transfer-accumulator-to-direct-page-626" title="TCD - Transfer Accumulator to Direct Page">TCD - Transfer Accumulator to Direct Page</a></li><li><a href="#tcs-transfer-accumulator-to-stack-633" title="TCS - Transfer Accumulator to Stack">TCS - Transfer Accumulator to Stack</a></li><li><a href="#tdc-transfer-direct-page-to-accumulator-634" title="TDC - Transfer Direct Page to Accumulator">TDC - Transfer Direct Page to Accumulator</a></li><li><a href="#tsc-transfer-stack-to-accumulator-640" title="TSC - Transfer Stack to Accumulator">TSC - Transfer Stack to Accumulator</a></li><li><a href="#tsx-transfer-stack-to-x-641" title="TSX - Transfer stack to X">TSX - Transfer stack to X</a></li><li><a href="#txa-transfer-x-to-accumulator-642" title="TXA - Transfer X to Accumulator">TXA - Transfer X to Accumulator</a></li><li><a href="#txs-transfer-x-to-stack-643" title="TXS - Transfer X to Stack">TXS - Transfer X to Stack</a></li><li><a href="#txy-transfer-x-to-y-644" title="TXY - Transfer X to Y">TXY - Transfer X to Y</a></li><li><a href="#tya-transfer-y-to-accumulator-645" title="TYA - Transfer Y to Accumulator">TYA - Transfer Y to Accumulator</a></li><li><a href="#tyx-transfer-y-to-x-646" title="TYX - Transfer Y to X">TYX - Transfer Y to X</a></li><li><a href="#trb-test-and-reset-bit-658" title="TRB - Test and Reset Bit">TRB - Test and Reset Bit</a></li><li><a href="#tsb-test-and-set-bit-661" title="TSB - Test and Set Bit">TSB - Test and Set Bit</a></li><li><a href="#wai-wait-for-interrupt-664" title="WAI - Wait for Interrupt">WAI - Wait for Interrupt</a></li><li><a href="#xce-exchange-carry-with-emulation-667" title="XCE - Exchange Carry with Emulation">XCE - Exchange Carry with Emulation</a></li></ul><li><a href="#datasheets-manuals-etc.-675" title="Datasheets, Manuals etc.">Datasheets, Manuals etc.</a></li></ul></ul></nav></p>
<h2 id="internal-registers-2">Internal Registers</h2>
<table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Friendly Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Accumulator</td>
<td>The accumulator. This is the math register. It stores one of two operands or the result of most arithmetic and logical operations.</td>
</tr>
<tr>
<td>X, Y</td>
<td>Index</td>
<td>The index registers. These can be used to reference memory, to pass data to memory, or as counters for loops.</td>
</tr>
<tr>
<td>S</td>
<td>Stack Pointer</td>
<td>The stack pointer, points to the next available(unused) location on the stack.</td>
</tr>
<tr>
<td>DBR / DB</td>
<td>Data Bank</td>
<td>Data bank register, holds the default bank for memory transfers.</td>
</tr>
<tr>
<td>D / DP</td>
<td>Direct Page</td>
<td>Direct page register, used for direct page addressing modes. Holds the memory bank address of the data the CPU is accessing.</td>
</tr>
<tr>
<td>PB / PBR</td>
<td>Program Bank</td>
<td>Program Bank, holds the bank address of all instruction fetches.</td>
</tr>
<tr>
<td>P</td>
<td>Processor Status</td>
<td>Holds various important flags, results of tests and 65816 processing states. See below.</td>
</tr>
<tr>
<td>PC</td>
<td>Program Counter</td>
<td>Holds the memory address of the current CPU instruction</td>
</tr>
</tbody>
</table>
<h3 id="flags-stored-in-p-register-15">Flags stored in P Register</h3>
<table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Value</th>
<th>Binary Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>#$80</td>
<td>10000000</td>
<td>Negative</td>
</tr>
<tr>
<td>V</td>
<td>#$40</td>
<td>01000000</td>
<td>Overflow</td>
</tr>
<tr>
<td>M</td>
<td>#$20</td>
<td>00100000</td>
<td>Accumulator register size (native mode only)&lt;br/&gt;(0 = 16-bit, 1 = 8-bit)</td>
</tr>
<tr>
<td>X</td>
<td>#$10</td>
<td>00010000</td>
<td>Index register size (native mode only)&lt;br/&gt;(0 = 16-bit, 1 = 8-bit)</td>
</tr>
<tr>
<td>D</td>
<td>#$08</td>
<td>00001000</td>
<td>Decimal</td>
</tr>
<tr>
<td>I</td>
<td>#$04</td>
<td>00000100</td>
<td>IRQ disable</td>
</tr>
<tr>
<td>Z</td>
<td>#$02</td>
<td>00000010</td>
<td>Zero</td>
</tr>
<tr>
<td>C</td>
<td>#$01</td>
<td>00000001</td>
<td>Carry</td>
</tr>
<tr>
<td>E</td>
<td></td>
<td></td>
<td>6502 emulation mode</td>
</tr>
<tr>
<td>B</td>
<td>#$10</td>
<td>00010000</td>
<td>Break (emulation mode only)</td>
</tr>
</tbody>
</table>
<h2 id="addressing-modes-30">Addressing Modes</h2>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implied</td>
<td>PHB</td>
</tr>
<tr>
<td>Immediate[MemoryFlag]</td>
<td>AND #1 or 2 bytes</td>
</tr>
<tr>
<td>Immediate[IndexFlag]</td>
<td>LDX #1 or 2 bytes</td>
</tr>
<tr>
<td>Immediate[8-Bit]</td>
<td>SEP #byte</td>
</tr>
<tr>
<td>Relative</td>
<td>BEQ byte (signed)</td>
</tr>
<tr>
<td>Relative long</td>
<td>BRL 2 bytes (signed)</td>
</tr>
<tr>
<td>Direct</td>
<td>AND byte</td>
</tr>
<tr>
<td>Direct indexed (with X)</td>
<td>AND byte, x</td>
</tr>
<tr>
<td>Direct indexed (with Y)</td>
<td>AND byte, y</td>
</tr>
<tr>
<td>Direct indirect</td>
<td>AND (byte)</td>
</tr>
<tr>
<td>Direct indexed indirect</td>
<td>AND (byte, x)</td>
</tr>
<tr>
<td>Direct indirect indexed</td>
<td>AND (byte), y</td>
</tr>
<tr>
<td>Direct indirect long</td>
<td>AND [byte]</td>
</tr>
<tr>
<td>Direct indirect indexed long</td>
<td>AND [byte], y</td>
</tr>
<tr>
<td>Absolute</td>
<td>AND 2bytes</td>
</tr>
<tr>
<td>Absolute indexed (with X)</td>
<td>AND 2bytes, x</td>
</tr>
<tr>
<td>Absolute indexed (with Y)</td>
<td>AND 2bytes, y</td>
</tr>
<tr>
<td>Absolute long</td>
<td>AND 3bytes</td>
</tr>
<tr>
<td>Absolute indexed long</td>
<td>AND 3bytes, x</td>
</tr>
<tr>
<td>Stack relative</td>
<td>AND byte, s</td>
</tr>
<tr>
<td>Stack relative indirect indexed</td>
<td>AND (byte, s), y</td>
</tr>
<tr>
<td>Absolute indirect</td>
<td>JMP (2bytes)</td>
</tr>
<tr>
<td>Absolute indirect long</td>
<td>JML [2bytes]</td>
</tr>
<tr>
<td>Absolute indexed indirect</td>
<td>JMP/JSR (2bytes,x)</td>
</tr>
<tr>
<td>Implied accumulator</td>
<td>INC</td>
</tr>
<tr>
<td>Block move</td>
<td>MVN/MVP byte, byte</td>
</tr>
</tbody>
</table>
<h2 id="instructions-61">Instructions</h2>
<p>Instructions are a breakdown of machine code. For the SNES, they consist of a 1-byte opcode followed by a 0-3 byte operand. Full instructions may be known as words. For example, the instruction <code>ADC $3a</code> occupies 2 bytes in memory, and if assembled, it would be stored as <code>E6 3A</code>.</p>
<p>Most instructions that are at least 2 bytes long have more than one addressing mode. Addressing modes are put in place so basic instructions may be interpreted correctly given a wide range of operands.</p>
<table>
<thead>
<tr>
<th>Assembler Example</th>
<th>Alias</th>
<th>Proper Name</th>
<th>HEX</th>
<th>Addressing Mode</th>
<th>Flags Set</th>
<th>Bytes</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADC (<em>dp</em>,X)</td>
<td></td>
<td>Add With Carry</td>
<td>61</td>
<td>DP Indexed Indirect,X</td>
<td>NV----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>ADC <em>sr</em>,S</td>
<td></td>
<td>Add With Carry</td>
<td>63</td>
<td>Stack Relative</td>
<td>NV----ZC</td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>ADC <em>dp</em></td>
<td></td>
<td>Add With Carry</td>
<td>65</td>
<td>Direct Page</td>
<td>NV----ZC</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>ADC [<em>dp</em>]</td>
<td></td>
<td>Add With Carry</td>
<td>67</td>
<td>DP Indirect Long</td>
<td>NV----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>ADC <em>#const</em></td>
<td></td>
<td>Add With Carry</td>
<td>69</td>
<td>Immediate</td>
<td>NV----ZC</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>ADC <em>addr</em></td>
<td></td>
<td>Add With Carry</td>
<td>6D</td>
<td>Absolute</td>
<td>NV----ZC</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>ADC <em>long</em></td>
<td></td>
<td>Add With Carry</td>
<td>6F</td>
<td>Absolute Long</td>
<td>NV----ZC</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>ADC ( <em>dp</em>),Y</td>
<td></td>
<td>Add With Carry</td>
<td>71</td>
<td>DP Indirect Indexed, Y</td>
<td>NV----ZC</td>
<td>2</td>
<td>5[^1][^2][^3]</td>
</tr>
<tr>
<td>ADC (<em>dp</em>)</td>
<td></td>
<td>Add With Carry</td>
<td>72</td>
<td>DP Indirect</td>
<td>NV----ZC</td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>ADC (<em>sr</em>,S),Y</td>
<td></td>
<td>Add With Carry</td>
<td>73</td>
<td>SR Indirect Indexed,Y</td>
<td>NV----ZC</td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>ADC <em>dp</em>,X</td>
<td></td>
<td>Add With Carry</td>
<td>75</td>
<td>DP Indexed,X</td>
<td>NV----ZC</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>ADC [<em>dp</em>],Y</td>
<td></td>
<td>Add With Carry</td>
<td>77</td>
<td>DP Indirect Long Indexed, Y</td>
<td>NV----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>ADC <em>addr</em>,Y</td>
<td></td>
<td>Add With Carry</td>
<td>79</td>
<td>Absolute Indexed,Y</td>
<td>NV----ZC</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>ADC <em>addr</em>,X</td>
<td></td>
<td>Add With Carry</td>
<td>7D</td>
<td>Absolute Indexed,X</td>
<td>NV----ZC</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>ADC  <em>long</em>,X</td>
<td></td>
<td>Add With Carry</td>
<td>7F</td>
<td>Absolute Long Indexed,X</td>
<td>NV----ZC</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>AND (_dp,_X)</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>21</td>
<td>DP Indexed Indirect,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>AND <em>sr,S</em></td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>23</td>
<td>Stack Relative</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>AND <em>dp</em></td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>25</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>AND [<em>dp</em>]</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>27</td>
<td>DP Indirect Long</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>AND <em>#const</em></td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>29</td>
<td>Immediate</td>
<td>N-----Z-</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>AND <em>addr</em></td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>2D</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>AND <em>long</em></td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>2F</td>
<td>Absolute Long</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>AND (<em>dp</em>),Y</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>31</td>
<td>DP Indirect Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2][^3]</td>
</tr>
<tr>
<td>AND (<em>dp</em>)</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>32</td>
<td>DP Indirect</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>AND (<em>sr</em>,S),Y</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>33</td>
<td>SR Indirect Indexed,Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>AND <em>dp</em>,X</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>35</td>
<td>DP Indexed,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>AND [<em>dp</em>],Y</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>37</td>
<td>DP Indirect Long Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>AND <em>addr</em>,Y</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>39</td>
<td>Absolute Indexed,Y</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>AND <em>addr</em>,X</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>3D</td>
<td>Absolute Indexed,X</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>AND  <em>long</em>,X</td>
<td></td>
<td>AND Accumulator with Memory</td>
<td>3F</td>
<td>Absolute Long Indexed,X</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>ASL <em>dp</em></td>
<td></td>
<td>Arithmetic Shift Left</td>
<td>06</td>
<td>Direct Page</td>
<td>N-----ZC</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>ASL A</td>
<td></td>
<td>Arithmetic Shift Left</td>
<td>0A</td>
<td>Accumulator</td>
<td>N-----ZC</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>ASL <em>addr</em></td>
<td></td>
<td>Arithmetic Shift Left</td>
<td>0E</td>
<td>Absolute</td>
<td>N-----ZC</td>
<td>3</td>
<td>6[^4]</td>
</tr>
<tr>
<td>ASL <em>dp</em>,X</td>
<td></td>
<td>Arithmetic Shift Left</td>
<td>16</td>
<td>DP Indexed,X</td>
<td>N-----ZC</td>
<td>2</td>
<td>6[^2][^4]</td>
</tr>
<tr>
<td>ASL <em>addr</em>,X</td>
<td></td>
<td>Arithmetic Shift Left</td>
<td>1E</td>
<td>Absolute Indexed,X</td>
<td>N-----ZC</td>
<td>3</td>
<td>7[^4]</td>
</tr>
<tr>
<td>BCC <em>nearlabel</em></td>
<td>BLT</td>
<td>Branch if Carry Clear</td>
<td>90</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>BCS <em>nearlabel</em></td>
<td>BGE</td>
<td>Branch if Carry Set</td>
<td>B0</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>BEQ <em>nearlabel</em></td>
<td></td>
<td>Branch if Equal</td>
<td>F0</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>BIT <em>dp</em></td>
<td></td>
<td>Test Bits</td>
<td>24</td>
<td>Direct Page</td>
<td>NV----Z-</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>BIT <em>addr</em></td>
<td></td>
<td>Test Bits</td>
<td>2C</td>
<td>Absolute</td>
<td>NV----Z-</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>BIT <em>dp</em>,X</td>
<td></td>
<td>Test Bits</td>
<td>34</td>
<td>DP Indexed,X</td>
<td>NV----Z-</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>BIT <em>addr</em>,X</td>
<td></td>
<td>Test Bits</td>
<td>3C</td>
<td>Absolute Indexed,X</td>
<td>NV----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>BIT <em>#const</em></td>
<td></td>
<td>Test Bits</td>
<td>89</td>
<td>Immediate</td>
<td>------Z-</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>BMI <em>nearlabel</em></td>
<td></td>
<td>Branch if Minus</td>
<td>30</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>BNE <em>nearlabel</em></td>
<td></td>
<td>Branch if Not Equal</td>
<td>D0</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>BPL <em>nearlabel</em></td>
<td></td>
<td>Branch if Plus</td>
<td>10</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>BRA <em>nearlabel</em></td>
<td></td>
<td>Branch Always</td>
<td>80</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>3[^6]</td>
</tr>
<tr>
<td>BRK</td>
<td></td>
<td>Break</td>
<td>00</td>
<td>Stack/Interrupt</td>
<td>----DI--</td>
<td>2[^13]</td>
<td>7[^7]</td>
</tr>
<tr>
<td>BRL <em>label</em></td>
<td></td>
<td>Branch Long Always</td>
<td>82</td>
<td>Program Counter Relative Long</td>
<td></td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>BVC <em>nearlabel</em></td>
<td></td>
<td>Branch if Overflow Clear</td>
<td>50</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>BVS <em>nearlabel</em></td>
<td></td>
<td>Branch if Overflow Set</td>
<td>70</td>
<td>Program Counter Relative</td>
<td></td>
<td>2</td>
<td>2[^5][^6]</td>
</tr>
<tr>
<td>CLC</td>
<td></td>
<td>Clear Carry</td>
<td>18</td>
<td>Implied</td>
<td>-------C</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>CLD</td>
<td></td>
<td>Clear Decimal Mode Flag</td>
<td>D8</td>
<td>Implied</td>
<td>----D---</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>CLI</td>
<td></td>
<td>Clear Interrupt Disable Flag</td>
<td>58</td>
<td>Implied</td>
<td>-----I--</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>CLV</td>
<td></td>
<td>Clear Overflow Flag</td>
<td>B8</td>
<td>Implied</td>
<td>-V------</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>CMP (_dp,_X)</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>C1</td>
<td>DP Indexed Indirect,X</td>
<td>N-----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>CMP <em>sr</em>,S</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>C3</td>
<td>Stack Relative</td>
<td>N-----ZC</td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>CMP <em>dp</em></td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>C5</td>
<td>Direct Page</td>
<td>N-----ZC</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>CMP [<em>dp</em>]</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>C7</td>
<td>DP Indirect Long</td>
<td>N-----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>CMP <em>#const</em></td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>C9</td>
<td>Immediate</td>
<td>N-----ZC</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>CMP <em>addr</em></td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>CD</td>
<td>Absolute</td>
<td>N-----ZC</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>CMP <em>long</em></td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>CF</td>
<td>Absolute Long</td>
<td>N-----ZC</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>CMP (<em>dp</em>),Y</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>D1</td>
<td>DP Indirect Indexed, Y</td>
<td>N-----ZC</td>
<td>2</td>
<td>5[^1][^2][^3]</td>
</tr>
<tr>
<td>CMP (<em>dp</em>)</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>D2</td>
<td>DP Indirect</td>
<td>N-----ZC</td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>CMP (<em>sr</em>,S),Y</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>D3</td>
<td>SR Indirect Indexed,Y</td>
<td>N-----ZC</td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>CMP <em>dp</em>,X</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>D5</td>
<td>DP Indexed,X</td>
<td>N-----ZC</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>CMP [<em>dp</em>],Y</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>D7</td>
<td>DP Indirect Long Indexed, Y</td>
<td>N-----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>CMP <em>addr</em>,Y</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>D9</td>
<td>Absolute Indexed,Y</td>
<td>N-----ZC</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>CMP <em>addr</em>,X</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>DD</td>
<td>Absolute Indexed,X</td>
<td>N-----ZC</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>CMP  <em>long</em>,X</td>
<td></td>
<td>Compare Accumulator with Memory</td>
<td>DF</td>
<td>Absolute Long Indexed,X</td>
<td>N-----ZC</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>COP <em>const</em></td>
<td></td>
<td>Co-Processor Enable</td>
<td>02</td>
<td>Stack/Interrupt</td>
<td>----DI--</td>
<td>2[^13]</td>
<td>7[^7]</td>
</tr>
<tr>
<td>CPX <em>#const</em></td>
<td></td>
<td>Compare Index Register X with Memory</td>
<td>E0</td>
<td>Immediate</td>
<td>N-----ZC</td>
<td>2[^14]</td>
<td>2[^8]</td>
</tr>
<tr>
<td>CPX <em>dp</em></td>
<td></td>
<td>Compare Index Register X with Memory</td>
<td>E4</td>
<td>Direct Page</td>
<td>N-----ZC</td>
<td>2</td>
<td>3[^2][^8]</td>
</tr>
<tr>
<td>CPX <em>addr</em></td>
<td></td>
<td>Compare Index Register X with Memory</td>
<td>EC</td>
<td>Absolute</td>
<td>N-----ZC</td>
<td>3</td>
<td>4[^8]</td>
</tr>
<tr>
<td>CPY <em>#const</em></td>
<td></td>
<td>Compare Index Register Y with Memory</td>
<td>C0</td>
<td>Immediate</td>
<td>N-----ZC</td>
<td>2[^14]</td>
<td>2[^8]</td>
</tr>
<tr>
<td>CPY <em>dp</em></td>
<td></td>
<td>Compare Index Register Y with Memory</td>
<td>C4</td>
<td>Direct Page</td>
<td>N-----ZC</td>
<td>2</td>
<td>3[^2][^8]</td>
</tr>
<tr>
<td>CPY <em>addr</em></td>
<td></td>
<td>Compare Index Register Y with Memory</td>
<td>CC</td>
<td>Absolute</td>
<td>N-----ZC</td>
<td>3</td>
<td>4[^8]</td>
</tr>
<tr>
<td>DEC A</td>
<td>DEA</td>
<td>Decrement</td>
<td>3A</td>
<td>Accumulator</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>DEC <em>dp</em></td>
<td></td>
<td>Decrement</td>
<td>C6</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>DEC <em>addr</em></td>
<td></td>
<td>Decrement</td>
<td>CE</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>6[^4]</td>
</tr>
<tr>
<td>DEC <em>dp</em>,X</td>
<td></td>
<td>Decrement</td>
<td>D6</td>
<td>DP Indexed,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^2][^4]</td>
</tr>
<tr>
<td>DEC <em>addr</em>,X</td>
<td></td>
<td>Decrement</td>
<td>DE</td>
<td>Absolute Indexed,X</td>
<td>N-----Z-</td>
<td>3</td>
<td>7[^4]</td>
</tr>
<tr>
<td>DEX</td>
<td></td>
<td>Decrement Index Register X</td>
<td>CA</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>DEY</td>
<td></td>
<td>Decrement Index Register Y</td>
<td>88</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>EOR (_dp,_X)</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>41</td>
<td>DP Indexed Indirect,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>EOR <em>sr</em>,S</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>43</td>
<td>Stack Relative</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>EOR <em>dp</em></td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>45</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>EOR [<em>dp</em>]</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>47</td>
<td>DP Indirect Long</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>EOR <em>#const</em></td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>49</td>
<td>Immediate</td>
<td>N-----Z-</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>EOR <em>addr</em></td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>4D</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>EOR <em>long</em></td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>4F</td>
<td>Absolute Long</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>EOR (<em>dp</em>),Y</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>51</td>
<td>DP Indirect Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2][^3]</td>
</tr>
<tr>
<td>EOR (<em>dp</em>)</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>52</td>
<td>DP Indirect</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>EOR (<em>sr</em>,S),Y</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>53</td>
<td>SR Indirect Indexed,Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>EOR <em>dp</em>,X</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>55</td>
<td>DP Indexed,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>EOR [<em>dp</em>],Y</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>57</td>
<td>DP Indirect Long Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>EOR <em>addr</em>,Y</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>59</td>
<td>Absolute Indexed,Y</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>EOR <em>addr</em>,X</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>5D</td>
<td>Absolute Indexed,X</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>EOR  <em>long</em>,X</td>
<td></td>
<td>Exclusive-OR Accumulator with Memory</td>
<td>5F</td>
<td>Absolute Long Indexed,X</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>INC A</td>
<td>INA</td>
<td>Increment</td>
<td>1A</td>
<td>Accumulator</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>INC <em>dp</em></td>
<td></td>
<td>Increment</td>
<td>E6</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>INC <em>addr</em></td>
<td></td>
<td>Increment</td>
<td>EE</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>6[^4]</td>
</tr>
<tr>
<td>INC <em>dp</em>,X</td>
<td></td>
<td>Increment</td>
<td>F6</td>
<td>DP Indexed,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^2][^4]</td>
</tr>
<tr>
<td>INC <em>addr</em>,X</td>
<td></td>
<td>Increment</td>
<td>FE</td>
<td>Absolute Indexed,X</td>
<td>N-----Z-</td>
<td>3</td>
<td>7[^4]</td>
</tr>
<tr>
<td>INX</td>
<td></td>
<td>Increment Index Register X</td>
<td>E8</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>INY</td>
<td></td>
<td>Increment Index Register Y</td>
<td>C8</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>JMP <em>addr</em></td>
<td></td>
<td>Jump</td>
<td>4C</td>
<td>Absolute</td>
<td></td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>JMP <em>long</em></td>
<td>JML</td>
<td>Jump</td>
<td>5C</td>
<td>Absolute Long</td>
<td></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>JMP (<em>addr</em>)</td>
<td></td>
<td>Jump</td>
<td>6C</td>
<td>Absolute Indirect</td>
<td></td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>JMP (<em>addr,X</em>)</td>
<td></td>
<td>Jump</td>
<td>7C</td>
<td>Absolute Indexed Indirect</td>
<td></td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>JMP <em>[addr]</em></td>
<td>JML</td>
<td>Jump</td>
<td>DC</td>
<td>Absolute Indirect Long</td>
<td></td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>JSR <em>addr</em></td>
<td></td>
<td>Jump to Subroutine</td>
<td>20</td>
<td>Absolute</td>
<td></td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>JSR <em>long</em></td>
<td>JSL</td>
<td>Jump to Subroutine</td>
<td>22</td>
<td>Absolute Long</td>
<td></td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>JSR <em>(addr,X)</em>)</td>
<td></td>
<td>Jump to Subroutine</td>
<td>FC</td>
<td>Absolute Indexed Indirect</td>
<td></td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>LDA (_dp,_X)</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>A1</td>
<td>DP Indexed Indirect,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>LDA <em>sr,S</em></td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>A3</td>
<td>Stack Relative</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>LDA <em>dp</em></td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>A5</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>LDA [<em>dp</em>]</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>A7</td>
<td>DP Indirect Long</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>LDA <em>#const</em></td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>A9</td>
<td>Immediate</td>
<td>N-----Z-</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>LDA <em>addr</em></td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>AD</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>LDA <em>long</em></td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>AF</td>
<td>Absolute Long</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>LDA (<em>dp</em>),Y</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>B1</td>
<td>DP Indirect Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2][^3]</td>
</tr>
<tr>
<td>LDA (<em>dp</em>)</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>B2</td>
<td>DP Indirect</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>LDA (<em>sr</em>,S),Y</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>B3</td>
<td>SR Indirect Indexed,Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>LDA <em>dp</em>,X</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>B5</td>
<td>DP Indexed,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>LDA [<em>dp</em>],Y</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>B7</td>
<td>DP Indirect Long Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>LDA <em>addr</em>,Y</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>B9</td>
<td>Absolute Indexed,Y</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>LDA <em>addr</em>,X</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>BD</td>
<td>Absolute Indexed,X</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>LDA  <em>long</em>,X</td>
<td></td>
<td>Load Accumulator from Memory</td>
<td>BF</td>
<td>Absolute Long Indexed,X</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>LDX <em>#const</em></td>
<td></td>
<td>Load Index Register X from Memory</td>
<td>A2</td>
<td>Immediate</td>
<td>N-----Z-</td>
<td>2[^14]</td>
<td>2[^8]</td>
</tr>
<tr>
<td>LDX <em>dp</em></td>
<td></td>
<td>Load Index Register X from Memory</td>
<td>A6</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>3[^2][^8]</td>
</tr>
<tr>
<td>LDX <em>addr</em></td>
<td></td>
<td>Load Index Register X from Memory</td>
<td>AE</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^8]</td>
</tr>
<tr>
<td>LDX <em>dp</em>,Y</td>
<td></td>
<td>Load Index Register X from Memory</td>
<td>B6</td>
<td>DP Indexed,Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^2][^8]</td>
</tr>
<tr>
<td>LDX <em>addr</em>,Y</td>
<td></td>
<td>Load Index Register X from Memory</td>
<td>BE</td>
<td>Absolute Indexed,Y</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^3][^8]</td>
</tr>
<tr>
<td>LDY <em>#const</em></td>
<td></td>
<td>Load Index Register Y from Memory</td>
<td>A0</td>
<td>Immediate</td>
<td>N-----Z-</td>
<td>2[^14]</td>
<td>2[^8]</td>
</tr>
<tr>
<td>LDY <em>dp</em></td>
<td></td>
<td>Load Index Register Y from Memory</td>
<td>A4</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>3[^2][^8]</td>
</tr>
<tr>
<td>LDY <em>addr</em></td>
<td></td>
<td>Load Index Register Y from Memory</td>
<td>AC</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^8]</td>
</tr>
<tr>
<td>LDY <em>dp</em>,X</td>
<td></td>
<td>Load Index Register Y from Memory</td>
<td>B4</td>
<td>DP Indexed,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^2][^8]</td>
</tr>
<tr>
<td>LDY <em>addr</em>,X</td>
<td></td>
<td>Load Index Register Y from Memory</td>
<td>BC</td>
<td>Absolute Indexed,X</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^3][^8]</td>
</tr>
<tr>
<td>LSR <em>dp</em></td>
<td></td>
<td>Logical Shift Memory or Accumulator Right</td>
<td>46</td>
<td>Direct Page</td>
<td>N-----ZC</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>LSR A</td>
<td></td>
<td>Logical Shift Memory or Accumulator Right</td>
<td>4A</td>
<td>Accumulator</td>
<td>N-----ZC</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>LSR <em>addr</em></td>
<td></td>
<td>Logical Shift Memory or Accumulator Right</td>
<td>4E</td>
<td>Absolute</td>
<td>N-----ZC</td>
<td>3</td>
<td>6[^4]</td>
</tr>
<tr>
<td>LSR <em>dp</em>,X</td>
<td></td>
<td>Logical Shift Memory or Accumulator Right</td>
<td>56</td>
<td>DP Indexed,X</td>
<td>N-----ZC</td>
<td>2</td>
<td>6[^2][^4]</td>
</tr>
<tr>
<td>LSR <em>addr</em>,X</td>
<td></td>
<td>Logical Shift Memory or Accumulator Right</td>
<td>5E</td>
<td>Absolute Indexed,X</td>
<td>N-----ZC</td>
<td>3</td>
<td>7[^4]</td>
</tr>
<tr>
<td>MVN <em>srcbk,destbk</em></td>
<td></td>
<td>Block Move Negative</td>
<td>54</td>
<td>Block Move</td>
<td></td>
<td>3</td>
<td>1[^3]</td>
</tr>
<tr>
<td>MVP <em>srcbk,destbk</em></td>
<td></td>
<td>Block Move Positive</td>
<td>44</td>
<td>Block Move</td>
<td></td>
<td>3</td>
<td>1[^3]</td>
</tr>
<tr>
<td>NOP</td>
<td></td>
<td>No Operation</td>
<td>EA</td>
<td>Implied</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>ORA (<em>dp</em>,X)</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>01</td>
<td>DP Indexed Indirect,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>ORA <em>sr</em>,S</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>03</td>
<td>Stack Relative</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>ORA <em>dp</em></td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>05</td>
<td>Direct Page</td>
<td>N-----Z-</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>ORA [<em>dp</em>]</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>07</td>
<td>DP Indirect Long</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>ORA <em>#const</em></td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>09</td>
<td>Immediate</td>
<td>N-----Z-</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>ORA <em>addr</em></td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>0D</td>
<td>Absolute</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>ORA <em>long</em></td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>0F</td>
<td>Absolute Long</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>ORA (<em>dp</em>),Y</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>11</td>
<td>DP Indirect Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2][^3]</td>
</tr>
<tr>
<td>ORA (<em>dp</em>)</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>12</td>
<td>DP Indirect</td>
<td>N-----Z-</td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>ORA (<em>sr</em>,S),Y</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>13</td>
<td>SR Indirect Indexed,Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>ORA <em>dp</em>,X</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>15</td>
<td>DP Indexed,X</td>
<td>N-----Z-</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>ORA [<em>dp</em>],Y</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>17</td>
<td>DP Indirect Long Indexed, Y</td>
<td>N-----Z-</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>ORA <em>addr</em>,Y</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>19</td>
<td>Absolute Indexed,Y</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>ORA <em>addr</em>,X</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>1D</td>
<td>Absolute Indexed,X</td>
<td>N-----Z-</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>ORA  <em>long</em>,X</td>
<td></td>
<td>OR Accumulator with Memory</td>
<td>1F</td>
<td>Absolute Long Indexed,X</td>
<td>N-----Z-</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>PEA <em>addr</em></td>
<td></td>
<td>Push Effective Absolute Address</td>
<td>F4</td>
<td>Stack (Absolute)</td>
<td></td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>PEI <em>(dp)</em></td>
<td></td>
<td>Push Effective Indirect Address</td>
<td>D4</td>
<td>Stack (DP Indirect)</td>
<td></td>
<td>2</td>
<td>6[^2]</td>
</tr>
<tr>
<td>PER <em>label</em></td>
<td></td>
<td>Push Effective PC Relative Indirect Address</td>
<td>62</td>
<td>Stack (PC Relative Long)</td>
<td></td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>PHA</td>
<td></td>
<td>Push Accumulator</td>
<td>48</td>
<td>Stack (Push)</td>
<td></td>
<td>1</td>
<td>3[^1]</td>
</tr>
<tr>
<td>PHB</td>
<td></td>
<td>Push Data Bank Register</td>
<td>8B</td>
<td>Stack (Push)</td>
<td></td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>PHD</td>
<td></td>
<td>Push Direct Page Register</td>
<td>0B</td>
<td>Stack (Push)</td>
<td></td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>PHK</td>
<td></td>
<td>Push Program Bank Register</td>
<td>4B</td>
<td>Stack (Push)</td>
<td></td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td><a href="/php">PHP</a></td>
<td></td>
<td>Push Processor Status Register</td>
<td>08</td>
<td>Stack (Push)</td>
<td></td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>PHX</td>
<td></td>
<td>Push Index Register X</td>
<td>DA</td>
<td>Stack (Push)</td>
<td></td>
<td>1</td>
<td>3[^8]</td>
</tr>
<tr>
<td>PHY</td>
<td></td>
<td>Push Index Register Y</td>
<td>5A</td>
<td>Stack (Push)</td>
<td></td>
<td>1</td>
<td>3[^8]</td>
</tr>
<tr>
<td>PLA</td>
<td></td>
<td>Pull Accumulator</td>
<td>68</td>
<td>Stack (Pull)</td>
<td>N-----Z-</td>
<td>1</td>
<td>4[^1]</td>
</tr>
<tr>
<td>PLB</td>
<td></td>
<td>Pull Data Bank Register</td>
<td>AB</td>
<td>Stack (Pull)</td>
<td>N-----Z-</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>PLD</td>
<td></td>
<td>Pull Direct Page Register</td>
<td>2B</td>
<td>Stack (Pull)</td>
<td>N-----Z-</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>PLP</td>
<td></td>
<td>Pull Processor Status Register</td>
<td>28</td>
<td>Stack (Pull)</td>
<td>NVMXDIZC</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>PLX</td>
<td></td>
<td>Pull Index Register X</td>
<td>FA</td>
<td>Stack (Pull)</td>
<td>N-----Z-</td>
<td>1</td>
<td>4[^8]</td>
</tr>
<tr>
<td>PLY</td>
<td></td>
<td>Pull Index Register Y</td>
<td>7A</td>
<td>Stack (Pull)</td>
<td>N-----Z-</td>
<td>1</td>
<td>4[^8]</td>
</tr>
<tr>
<td>REP <em>#const</em></td>
<td></td>
<td>Reset Processor Status Bits</td>
<td>C2</td>
<td>Immediate</td>
<td>NVMXDIZC</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>ROL <em>dp</em></td>
<td></td>
<td>Rotate Memory or Accumulator Left</td>
<td>26</td>
<td>Direct Page</td>
<td>N-----ZC</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>ROL A</td>
<td></td>
<td>Rotate Memory or Accumulator Left</td>
<td>2A</td>
<td>Accumulator</td>
<td>N-----ZC</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>ROL <em>addr</em></td>
<td></td>
<td>Rotate Memory or Accumulator Left</td>
<td>2E</td>
<td>Absolute</td>
<td>N-----ZC</td>
<td>3</td>
<td>6[^4]</td>
</tr>
<tr>
<td>ROL <em>dp</em>,X</td>
<td></td>
<td>Rotate Memory or Accumulator Left</td>
<td>36</td>
<td>DP Indexed,X</td>
<td>N-----ZC</td>
<td>2</td>
<td>6[^2][^4]</td>
</tr>
<tr>
<td>ROL <em>addr</em>,X</td>
<td></td>
<td>Rotate Memory or Accumulator Left</td>
<td>3E</td>
<td>Absolute Indexed,X</td>
<td>N-----ZC</td>
<td>3</td>
<td>7[^4]</td>
</tr>
<tr>
<td>ROR <em>dp</em></td>
<td></td>
<td>Rotate Memory or Accumulator Right</td>
<td>66</td>
<td>Direct Page</td>
<td>N-----ZC</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>ROR A</td>
<td></td>
<td>Rotate Memory or Accumulator Right</td>
<td>6A</td>
<td>Accumulator</td>
<td>N-----ZC</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>ROR <em>addr</em></td>
<td></td>
<td>Rotate Memory or Accumulator Right</td>
<td>6E</td>
<td>Absolute</td>
<td>N-----ZC</td>
<td>3</td>
<td>6[^4]</td>
</tr>
<tr>
<td>ROR <em>dp</em>,X</td>
<td></td>
<td>Rotate Memory or Accumulator Right</td>
<td>76</td>
<td>DP Indexed,X</td>
<td>N-----ZC</td>
<td>2</td>
<td>6[^2][^4]</td>
</tr>
<tr>
<td>ROR <em>addr</em>,X</td>
<td></td>
<td>Rotate Memory or Accumulator Right</td>
<td>7E</td>
<td>Absolute Indexed,X</td>
<td>N-----ZC</td>
<td>3</td>
<td>7[^4]</td>
</tr>
<tr>
<td>RTI</td>
<td></td>
<td>Return from Interrupt</td>
<td>40</td>
<td>Stack (RTI)</td>
<td>NVMXDIZC</td>
<td>1</td>
<td>6[^7]</td>
</tr>
<tr>
<td>RTL</td>
<td></td>
<td>Return from Subroutine Long</td>
<td>6B</td>
<td>Stack (RTL)</td>
<td></td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>RTS</td>
<td></td>
<td>Return from Subroutine</td>
<td>60</td>
<td>Stack (RTS)</td>
<td></td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>SBC (_dp,_X)</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>E1</td>
<td>DP Indexed Indirect,X</td>
<td>NV----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>SBC <em>sr</em>,S</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>E3</td>
<td>Stack Relative</td>
<td>NV----ZC</td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>SBC <em>dp</em></td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>E5</td>
<td>Direct Page</td>
<td>NV----ZC</td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>SBC [<em>dp</em>]</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>E7</td>
<td>DP Indirect Long</td>
<td>NV----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>SBC <em>#const</em></td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>E9</td>
<td>Immediate</td>
<td>NV----ZC</td>
<td>2[^12]</td>
<td>2[^1]</td>
</tr>
<tr>
<td>SBC <em>addr</em></td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>ED</td>
<td>Absolute</td>
<td>NV----ZC</td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>SBC <em>long</em></td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>EF</td>
<td>Absolute Long</td>
<td>NV----ZC</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>SBC (<em>dp</em>),Y</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>F1</td>
<td>DP Indirect Indexed, Y</td>
<td>NV----ZC</td>
<td>2</td>
<td>5[^1][^2][^3]</td>
</tr>
<tr>
<td>SBC (<em>dp</em>)</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>F2</td>
<td>DP Indirect</td>
<td>NV----ZC</td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>SBC (<em>sr</em>,S),Y</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>F3</td>
<td>SR Indirect Indexed,Y</td>
<td>NV----ZC</td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>SBC <em>dp</em>,X</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>F5</td>
<td>DP Indexed,X</td>
<td>NV----ZC</td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>SBC [<em>dp</em>],Y</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>F7</td>
<td>DP Indirect Long Indexed, Y</td>
<td>NV----ZC</td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>SBC <em>addr</em>,Y</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>F9</td>
<td>Absolute Indexed,Y</td>
<td>NV----ZC</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>SBC <em>addr</em>,X</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>FD</td>
<td>Absolute Indexed,X</td>
<td>NV----ZC</td>
<td>3</td>
<td>4[^1][^3]</td>
</tr>
<tr>
<td>SBC  <em>long</em>,X</td>
<td></td>
<td>Subtract with Borrow from Accumulator</td>
<td>FF</td>
<td>Absolute Long Indexed,X</td>
<td>NV----ZC</td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>SEC</td>
<td></td>
<td>Set Carry Flag</td>
<td>38</td>
<td>Implied</td>
<td>-------C</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>SED</td>
<td></td>
<td>Set Decimal Flag</td>
<td>F8</td>
<td>Implied</td>
<td>----D---</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>SEI</td>
<td></td>
<td>Set Interrupt Disable Flag</td>
<td>78</td>
<td>Implied</td>
<td>-----I--</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>SEP <em>#const</em></td>
<td></td>
<td>Set Processor Status Bits</td>
<td>E2</td>
<td>Immediate</td>
<td>NVMXDIZC</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>STA (_dp,_X)</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>81</td>
<td>DP Indexed Indirect,X</td>
<td></td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>STA <em>sr</em>,S</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>83</td>
<td>Stack Relative</td>
<td></td>
<td>2</td>
<td>4[^1]</td>
</tr>
<tr>
<td>STA <em>dp</em></td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>85</td>
<td>Direct Page</td>
<td></td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>STA [<em>dp</em>]</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>87</td>
<td>DP Indirect Long</td>
<td></td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>STA <em>addr</em></td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>8D</td>
<td>Absolute</td>
<td></td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>STA <em>long</em></td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>8F</td>
<td>Absolute Long</td>
<td></td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>STA (<em>dp</em>),Y</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>91</td>
<td>DP Indirect Indexed, Y</td>
<td></td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>STA (<em>dp</em>)</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>92</td>
<td>DP Indirect</td>
<td></td>
<td>2</td>
<td>5[^1][^2]</td>
</tr>
<tr>
<td>STA (<em>sr</em>,S),Y</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>93</td>
<td>SR Indirect Indexed,Y</td>
<td></td>
<td>2</td>
<td>7[^1]</td>
</tr>
<tr>
<td>STA _dp_X</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>95</td>
<td>DP Indexed,X</td>
<td></td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>STA [<em>dp</em>],Y</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>97</td>
<td>DP Indirect Long Indexed, Y</td>
<td></td>
<td>2</td>
<td>6[^1][^2]</td>
</tr>
<tr>
<td>STA <em>addr</em>,Y</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>99</td>
<td>Absolute Indexed,Y</td>
<td></td>
<td>3</td>
<td>5[^1]</td>
</tr>
<tr>
<td>STA <em>addr</em>,X</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>9D</td>
<td>Absolute Indexed,X</td>
<td></td>
<td>3</td>
<td>5[^1]</td>
</tr>
<tr>
<td>STA  <em>long</em>,X</td>
<td></td>
<td>Store Accumulator to Memory</td>
<td>9F</td>
<td>Absolute Long Indexed,X</td>
<td></td>
<td>4</td>
<td>5[^1]</td>
</tr>
<tr>
<td>STP</td>
<td></td>
<td>Stop Processor</td>
<td>DB</td>
<td>Implied</td>
<td></td>
<td>1</td>
<td>3[^9]</td>
</tr>
<tr>
<td>STX <em>dp</em></td>
<td></td>
<td>Store Index Register X to Memory</td>
<td>86</td>
<td>Direct Page</td>
<td></td>
<td>2</td>
<td>3[^2][^8]</td>
</tr>
<tr>
<td>STX <em>addr</em></td>
<td></td>
<td>Store Index Register X to Memory</td>
<td>8E</td>
<td>Absolute</td>
<td></td>
<td>3</td>
<td>4[^8]</td>
</tr>
<tr>
<td>STX <em>dp</em>,Y</td>
<td></td>
<td>Store Index Register X to Memory</td>
<td>96</td>
<td>DP Indexed,Y</td>
<td></td>
<td>2</td>
<td>4[^2][^8]</td>
</tr>
<tr>
<td>STY <em>dp</em></td>
<td></td>
<td>Store Index Register Y to Memory</td>
<td>84</td>
<td>Direct Page</td>
<td></td>
<td>2</td>
<td>3[^2][^8]</td>
</tr>
<tr>
<td>STY <em>addr</em></td>
<td></td>
<td>Store Index Register Y to Memory</td>
<td>8C</td>
<td>Absolute</td>
<td></td>
<td>3</td>
<td>4[^8]</td>
</tr>
<tr>
<td>STY <em>dp</em>,X</td>
<td></td>
<td>Store Index Register Y to Memory</td>
<td>94</td>
<td>DP Indexed,X</td>
<td></td>
<td>2</td>
<td>4[^2][^8]</td>
</tr>
<tr>
<td>STZ <em>dp</em></td>
<td></td>
<td>Store Zero to Memory</td>
<td>64</td>
<td>Direct Page</td>
<td></td>
<td>2</td>
<td>3[^1][^2]</td>
</tr>
<tr>
<td>STZ <em>dp</em>,X</td>
<td></td>
<td>Store Zero to Memory</td>
<td>74</td>
<td>DP Indexed,X</td>
<td></td>
<td>2</td>
<td>4[^1][^2]</td>
</tr>
<tr>
<td>STZ <em>addr</em></td>
<td></td>
<td>Store Zero to Memory</td>
<td>9C</td>
<td>Absolute</td>
<td></td>
<td>3</td>
<td>4[^1]</td>
</tr>
<tr>
<td>STZ <em>addr</em>,X</td>
<td></td>
<td>Store Zero to Memory</td>
<td>9E</td>
<td>Absolute Indexed,X</td>
<td></td>
<td>3</td>
<td>5[^1]</td>
</tr>
<tr>
<td>TAX</td>
<td></td>
<td>Transfer Accumulator to Index Register X</td>
<td>AA</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TAY</td>
<td></td>
<td>Transfer Accumulator to Index Register Y</td>
<td>A8</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TCD</td>
<td></td>
<td>Transfer 16-bit Accumulator to Direct Page Register</td>
<td>5B</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TCS</td>
<td></td>
<td>Transfer 16-bit Accumulator to Stack Pointer</td>
<td>1B</td>
<td>Implied</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TDC</td>
<td></td>
<td>Transfer Direct Page Register to 16-bit Accumulator</td>
<td>7B</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TRB <em>dp</em></td>
<td></td>
<td>Test and Reset Memory Bits Against Accumulator</td>
<td>14</td>
<td>Direct Page</td>
<td>------Z-</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>TRB <em>addr</em></td>
<td></td>
<td>Test and Reset Memory Bits Against Accumulator</td>
<td>1C</td>
<td>Absolute</td>
<td>------Z-</td>
<td>3</td>
<td>6[^3]</td>
</tr>
<tr>
<td>TSB <em>dp</em></td>
<td></td>
<td>Test and Set Memory Bits Against Accumulator</td>
<td>04</td>
<td>Direct Page</td>
<td>------Z-</td>
<td>2</td>
<td>5[^2][^4]</td>
</tr>
<tr>
<td>TSB <em>addr</em></td>
<td></td>
<td>Test and Set Memory Bits Against Accumulator</td>
<td>0C</td>
<td>Absolute</td>
<td>------Z-</td>
<td>3</td>
<td>6[^4]</td>
</tr>
<tr>
<td>TSC</td>
<td></td>
<td>Transfer Stack Pointer to 16-bit Accumulator</td>
<td>3B</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TSX</td>
<td></td>
<td>Transfer Stack Pointer to Index Register X</td>
<td>BA</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TXA</td>
<td></td>
<td>Transfer Index Register X to Accumulator</td>
<td>8A</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TXS</td>
<td></td>
<td>Transfer Index Register X to Stack Pointer</td>
<td>9A</td>
<td>Implied</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TXY</td>
<td></td>
<td>Transfer Index Register X to Index Register Y</td>
<td>9B</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TYA</td>
<td></td>
<td>Transfer Index Register Y to Accumulator</td>
<td>98</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>TYX</td>
<td></td>
<td>Transfer Index Register Y to Index Register X</td>
<td>BB</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>WAI</td>
<td></td>
<td>Wait for Interrupt</td>
<td>CB</td>
<td>Implied</td>
<td></td>
<td>1</td>
<td>3[^10]</td>
</tr>
<tr>
<td>WDM</td>
<td></td>
<td><em>Reserved for Future Expansion</em></td>
<td>42</td>
<td></td>
<td></td>
<td>2</td>
<td>0[^11]</td>
</tr>
<tr>
<td><a href="/xba">XBA</a></td>
<td></td>
<td>Exchange B and A 8-bit Accumulators</td>
<td>EB</td>
<td>Implied</td>
<td>N-----Z-</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>XCE</td>
<td></td>
<td>Exchange Carry and Emulation Flags</td>
<td>FB</td>
<td>Implied</td>
<td>--MX---CE</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>[^1]: Add 1 cycle if m=0 (16-bit memory/accumulator)</p>
<p>[^2]: Add 1 cycle if low byte of Direct Page Register is non-zero</p>
<p>[^3]: Add 1 cycle if adding index crosses a page boundary or x=0 (16-bit index registers)</p>
<p>[^4]: Add 2 cycles if m=0 (16-bit memory/accumulator)</p>
<p>[^5]: Add 1 cycle if branch is taken</p>
<p>[^6]: Add 1 cycle if branch taken crosses page boundary in emulation mode (e=1)</p>
<p>[^7]: Add 1 cycle for 65816 native mode (e=0)</p>
<p>[^8]: Add 1 cycle if x=0 (16-bit index registers)</p>
<p>[^9]: Uses 3 cycles to shut the processor down: additional cycles are required by reset to restart it</p>
<p>[^10]: Uses 3 cycles to shut the processor down: additional cycles are required by interrupt to restart it</p>
<p>[^11]: Byte and cycle counts subject to change in future processors which expand WDM into 2-byte opcode portions of instructions of varying lengths</p>
<p>[^12]: Add 1 byte if m=0 (16-bit memory/accumulator)</p>
<p>[^13]: Opcode is 1 byte, but program counter value pushed onto stack is incremented by 2 allowing for optional signature byte</p>
<p>[^14]: Add 1 byte if x=0 (16-bit index registers)</p>
<h3 id="instruction-usage-353">Instruction Usage</h3>
<h4 id="adc-add-with-carry-355">ADC - Add with carry</h4>
<p>Adds operand to the Accumulator; adds an additional 1 if carry is set.</p>
<pre><code>A: 0010    adc #$50    ; adds $50 to accumulator or 51 if carry is set
A: 0060            ; result
</code></pre>
<h4 id="and-perform-and-to-accumulator-361">AND - Perform AND to Accumulator</h4>
<p>The operand is &quot;AND&quot;ed to the Accumulator. eg.</p>
<pre><code>A: 0010    and #$80    ; &quot;AND&quot;s $80 to accumulator
A: 0000
</code></pre>
<h4 id="asl-left-shifts-accumulator-memory-367">ASL - Left shifts Accumulator, Memory</h4>
<p>Shifts Memory or Accumulator left one bit. eg.</p>
<pre><code>A: 0010    asl A    ; Shift left by 1: 0x10 &lt;&lt; 1
A: 0020
</code></pre>
<h4 id="bcc-branch-if-carry-clear-373">BCC - Branch if carry clear</h4>
<p>Jump to a new location within the -128 to 127 range if the carry flag is clear. Useful for comparing two numbers, branching if the second number less than the first. eg.</p>
<pre><code>P: --mxdi--        bcc next    ; since the carry flag is clear, it'll jump to next
                   lda #$00    ; this will not be executed
          next:    lda #$40
</code></pre>
<h4 id="bcs-branch-if-carry-set-380">BCS - Branch if carry set</h4>
<p>Like BCC, but only when carry is set. Good for branching &quot;if greater than or equal to&quot; in a comparison.</p>
<h4 id="beq-branch-if-equal-383">BEQ - Branch if equal</h4>
<p>Branches is zero flag is set. This is useful for comparing numbers. eg.</p>
<pre><code> cpx #$50    ; if X is = $50, the zero flag is set
 beq next    ; branches to next if X = $50
 lda #$44
next:
 lda #$00
</code></pre>
<h4 id="bit-bit-test-392">BIT - Bit Test</h4>
<p>Performs AND except only the flags are modified. eg.</p>
<pre><code>A: 0010    bit #$80    ; &quot;AND&quot;s $80 to accumulator but result not stored
A: 0010
</code></pre>
<h4 id="bmi-branch-if-minus-398">BMI - Branch if Minus</h4>
<p>Branches if negative flag is set.</p>
<h4 id="bne-branch-if-not-equal-401">BNE - Branch if not equal</h4>
<p>Branches if zero flag clear. Good when used with comparison. You can branch if the number it not equal to.</p>
<h4 id="bpl-branch-if-plus-404">BPL - Branch if plus</h4>
<p>Branches if negative flag clear.</p>
<h4 id="bra-branch-always-407">BRA - Branch always</h4>
<p>Branch to location PC + n where n is the difference between the current PC and the label we want to branch to.</p>
<h4 id="brk-break-to-instruction-410">BRK - Break to instruction</h4>
<p>Causes a software break. The PC is loaded from a vector table from somewhere around <code>$FFE6</code>.</p>
<h4 id="brl-branch-relative-long-413">BRL - Branch Relative Long</h4>
<p>Like BRA but with longer range (-32768 to 32767).</p>
<h4 id="bvc-branch-if-overflow-clear-416">BVC - Branch if Overflow Clear</h4>
<p>Branches if overflow flag is clear.</p>
<h4 id="bvs-branch-if-overflow-set-419">BVS - Branch if Overflow Set</h4>
<p>Opposite of BVC.</p>
<h4 id="clc-clear-carry-flag-422">CLC - Clear Carry Flag</h4>
<p>Clears the carry flag.</p>
<h4 id="cld-clear-decimal-flag-425">CLD - Clear Decimal Flag</h4>
<p>Clears the decimal flag.</p>
<h4 id="cli-clear-interrupt-flag-428">CLI - Clear Interrupt Flag</h4>
<p>Clears the interrupt Flag.</p>
<h4 id="clv-clear-overflow-flag-431">CLV - Clear Overflow Flag</h4>
<p>Clears the Overflow flag.</p>
<h4 id="cmp-compare-accumulator-with-memory-434">CMP - Compare Accumulator with memory</h4>
<h4 id="cpx-compare-x-with-memory-435">CPX - Compare X with memory</h4>
<h4 id="cpy-compare-y-with-memory-436">CPY - Compare Y with memory</h4>
<p>Compares Accumulator, X or Y with the operand. The <code>n-----zc</code> flags are affected by the comparison. If the result is negative, the n flag is set. If the result is zero (or equal), the z flag is set. Carry is clear when borrow is required; that is, if the register is less than the operand. eg.</p>
<pre><code>A: 0020 P: --mx-i--        cmp #$20    ; compare accumulator with $20, if equal, z flag is set
A: 0020 P: --mx-iz-        beq next    ; branch if equal
</code></pre>
<h4 id="cop-coprocessor-empowerment-442">COP - Coprocessor Empowerment</h4>
<p>Causes a software interrupt using a vector.</p>
<h4 id="dec-decrement-accumulator-445">DEC - Decrement Accumulator</h4>
<h4 id="dex-decrement-x-446">DEX - Decrement X</h4>
<h4 id="dey-decrement-y-447">DEY - Decrement Y</h4>
<p>Subtracts 1 from A, X or Y. eg.</p>
<pre><code>Y: 0001    dey
Y: 0000
</code></pre>
<h4 id="eor-exclusive-or-accumulator-453">EOR - Exclusive OR accumulator</h4>
<p>Also known as &quot;XOR&quot;.  Performs XOR to the Accumulator. eg.</p>
<pre><code>A: FFFF    eor #$DDDD
A: 2222
</code></pre>
<h4 id="inc-increment-accumulator-459">INC - Increment Accumulator</h4>
<h4 id="inx-increment-x-460">INX - Increment X</h4>
<h4 id="iny-increment-y-461">INY - Increment Y</h4>
<p>Adds 1 to A, X or Y. eg.</p>
<pre><code>A: 0000    inc
A: 0001
</code></pre>
<h4 id="jmp-jump-to-location-467">JMP - Jump to location</h4>
<h4 id="jml-jump-long-468">JML - Jump long</h4>
<p>The JMP command will jump to a location within the bank. The JML will jump to places out of the current bank. eg.</p>
<pre><code>PBR: $80    jmp $5500      ; jumps to $80:5500
PBR: $80    jml $908000    ; jumps to $90:8000
PBR: $90                   ; the PBR is updated in long jump
</code></pre>
<h4 id="jsr-jump-subroutine-475">JSR - Jump Subroutine</h4>
<h4 id="jsl-jump-subroutine-long-476">JSL - Jump Subroutine Long</h4>
<p>If you already know a programming language, this is basically calling a function. This performs the same as JMP except the address of the current program counter is saved. In subroutines, the RTS and RTL are used to return back to the saved address.</p>
<h4 id="lda-load-accumulator-with-memory-479">LDA - Load Accumulator with memory</h4>
<h4 id="ldx-load-x-with-memory-480">LDX - Load X with memory</h4>
<h4 id="ldy-load-y-with-memory-481">LDY - Load Y with memory</h4>
<p>Loads the Accumulator, X, Y with a value.</p>
<h4 id="lsr-shift-right-accumulator-memory-484">LSR - Shift Right Accumulator, Memory</h4>
<p>Shifts Memory or Accumulator right one bit. eg.</p>
<pre><code>A: 0080    lsr A    ; Shift right by 1: 0x80 &gt;&gt; 1
A: 0040
</code></pre>
<h4 id="mvn-block-move-negative-490">MVN - Block move negative</h4>
<h4 id="mvp-block-move-positive-491">MVP - Block move positive</h4>
<p>A should hold the number of bytes to transfer minus one, meaning that a value of zero will transfer one byte. X and Y are the source and destination addresses, respectively, leaving out the banks. The banks are passed as the two operands of the instruction.</p>
<p>In MVN, X and Y are the bottom bytes of the source and destination blocks. After a byte is copied, both X and Y are incremented and A is decremented until A reaches $FFFF (after decrementing $0000), meaning that bytes from X to X + A were copied to the range from Y to Y + A.</p>
<p>In MVP, X and Y are the top bytes of the source and destination blocks. X, Y and A are decremented after each byte is copied, until A reaches $FFFF, so bytes from X to X - A are copied to the range from Y to Y - A.</p>
<p>Usually, MVN is used when the destination range is in a lower address than the source, otherwise MVP is used. This is a rule that avoids problems when the two address ranges overlap, assuring that every overlapping byte is read before being overwritten. However, as long as the programmer is aware of the consequences, it is possible to get useful results using the instructions the other way.</p>
<pre><code>                           ; This example follows the rule of thumb: (src &lt; dest) -&gt; mvp
                           ; So it copies the memory as expected
X: ???? Y: ???? A: ????    rep #$30     ; Make Accumulator and index 16-bit
X: ???? Y: ???? A: ????    ldx #$1100   ; Set X to $1100
X: 1100 Y: ???? A: ????    ldy #$1180   ; Set Y to $1180
X: 1100 Y: 1180 A: ????    lda #$00FF   ; Set A to $00FF
X: 1100 Y: 1180 A: 00FF    mvp $7E,$7E  ; Block move $100 bytes from $7E:1001-1100 -&gt; $7E:1081-1180
X: 1000 Y: 1080 A: FFFF    ...

                           ; This example does not follow the rule
                           ; (taken from Bushi Seiryuuden, 808B2F-808B3A)
                           ; In this case, two bytes are repeated over and over
X: ???? Y: ???? A: ????    ldx #$28C0   ; Set X to $28C0
X: 28C0 Y: ???? A: ????    ldy #$28C2   ; Set Y to $28C2
X: 28C0 Y: 28C2 A: ????    lda #$013D   ; Set A to $013D
X: 28C0 Y: 28C2 A: 013D    mvn $7E,$7E  ; The values at $7E:28C0-28C1 are repeated for $013E bytes
X: 29FE Y: 2A00 A: FFFF    ...
</code></pre>
<h4 id="nop-no-operation-518">NOP - No operation</h4>
<p>Does nothing but take up 2 cycles.</p>
<h4 id="ora-or-accumulator-with-memory-521">ORA - OR Accumulator with memory</h4>
<p>Performs &quot;OR&quot; to Accumulator. eg.</p>
<pre><code>A: 005F    ora #$7F    ; 0x5F | 0x7F
A: 007F
</code></pre>
<h4 id="pea-push-effective-address-527">PEA - Push Effective Address</h4>
<p>Pushes a 16-bit operand onto the stack. The instruction is very misleading because you are really pushing an immediate onto the stack. eg.</p>
<pre><code>S: 1FFF    pea $FFFF    ; Pushes $FFFF onto the stack
S: 1FFD                 ; stack decrements by 2
</code></pre>
<h4 id="pei-push-effective-indirect-address-533">PEI - Push Effective Indirect Address</h4>
<p>Pushes a 16-bit value from the indirect address of the operand. eg.</p>
<pre><code>Memory Dump:
0000: 23 33 45 22 DD C7 FF 8D
0001: 99 99 90 88 DD FF CC 67
S: 1FFF    pei ($01)    ; push $4533 on the stack
S: 1FFD
</code></pre>
<h4 id="per-push-program-counter-relative-542">PER - Push Program Counter Relative</h4>
<p>Pushes a 16-bit from that address taken by the current PC added to the operand. The range must be within (<code>0-65535</code>).</p>
<h4 id="pha-push-accumulator-545">PHA - Push Accumulator</h4>
<h4 id="phd-push-direct-page-register-546">PHD - Push Direct Page Register</h4>
<h4 id="phk-push-program-bank-547">PHK - Push Program Bank</h4>
<h4 id="phx-push-x-548">PHX - Push X</h4>
<h4 id="phy-push-y-549">PHY - Push Y</h4>
<p>Pushes the operand onto the stack.</p>
<h4 id="pla-pull-accumulator-552">PLA - Pull Accumulator</h4>
<h4 id="pld-pull-direct-page-register-553">PLD - Pull Direct Page Register</h4>
<h4 id="plp-pull-flags-554">PLP - Pull Flags</h4>
<h4 id="plx-pull-x-555">PLX - Pull X</h4>
<h4 id="ply-pull-y-556">PLY - Pull Y</h4>
<p>Pops a value off the stack and stores it in the operand.</p>
<h4 id="rep-reset-flag-559">REP - Reset Flag</h4>
<p>Clears the bits specified in the operands of the flag. eg.</p>
<pre><code>rep #$30    ; Clears bit 4 &amp; 5 to make A, X, Y 16-bits
</code></pre>
<h4 id="rol-rotate-bit-left-564">ROL - Rotate Bit Left</h4>
<p>Equivalent to ASL, except the carry flag rather than a zero is shifted into the least significant bit. This operation acts as a 9-bit rotation in 8-bit mode or a 17-bit rotation in 16-bit mode.</p>
<pre><code>A: 8000    rol A    ; rotate 1 left
A: 0001
</code></pre>
<h4 id="ror-rotate-bit-right-570">ROR - Rotate Bit Right</h4>
<p>Equivalent to LSR, except the carry flag rather than a zero is shifted into the most significant bit rather than a zero. This operation acts as a 9-bit rotation in 8-bit mode or a 17-bit rotation in 16-bit mode.</p>
<pre><code>A: 0001    ror A    ; rotate 1 right
A: 8000
</code></pre>
<h4 id="rti-return-from-interrupt-576">RTI - Return from Interrupt</h4>
<p>Used to return from a interrupt handler.</p>
<h4 id="rts-return-from-subroutine-579">RTS - Return from Subroutine</h4>
<h4 id="rtl-return-from-subroutine-long-580">RTL - Return from Subroutine Long</h4>
<p>Return the PC to the saved address caused by the JSR and JSL command. eg.</p>
<pre><code>    jsl sub    ; jump to subroutine at label &quot;sub&quot;
    .
    .
    .
sub:
    lda #$0000    ; some code
    rtl        ; return
</code></pre>
<h4 id="sbc-subtract-with-carry-591">SBC - Subtract with Carry</h4>
<p>Subtracts operand from the Accumulator; subtracts an additional 1 if carry is <strong>clear</strong>.</p>
<h4 id="sec-set-carry-flag-594">SEC - Set Carry Flag</h4>
<p>Sets the carry flag.</p>
<h4 id="sed-set-decimal-flag-597">SED - Set Decimal Flag</h4>
<p>Sets the decimal flag.</p>
<h4 id="sei-set-interrupt-flag-600">SEI - Set Interrupt Flag</h4>
<p>Sets the interrupt flag.</p>
<h4 id="sep-set-flag-603">SEP - Set Flag</h4>
<p>Sets certain bits of the flag depending on the operand. eg.</p>
<pre><code>sep #$20    ; set bit 5 of P to make A 8-bits
</code></pre>
<h4 id="sta-store-accumulator-to-memory-608">STA - Store Accumulator to memory</h4>
<h4 id="stx-store-x-to-memory-609">STX - Store X to memory</h4>
<h4 id="sty-store-y-to-memory-610">STY - Store Y to memory</h4>
<p>Stores the Accumulator, X or Y to a memory location. eg.</p>
<pre><code>A: 000F    sep #$20    ; 8-bit A
A: 000F    sta $2100    ; Stores $0F to $2100
</code></pre>
<h4 id="stp-stop-the-clock-616">STP - Stop the clock</h4>
<p>Dies.</p>
<h4 id="stz-store-zero-to-memory-619">STZ - Store zero to memory</h4>
<p>Stores zero to a memory location. eg.</p>
<pre><code>stz $2101    ; store 0 to $2101
</code></pre>
<h4 id="tax-transfer-accumulator-to-x-624">TAX - Transfer Accumulator to X</h4>
<h4 id="tay-transfer-accumulator-to-y-625">TAY - Transfer Accumulator to Y</h4>
<h4 id="tcd-transfer-accumulator-to-direct-page-626">TCD - Transfer Accumulator to Direct Page</h4>
<p>sets the direct page to whatever is in A</p>
<pre><code>lda #$0000    ;the C refers to 16bit A
tcd
lda $34       ;same as lda $0034
</code></pre>
<h4 id="tcs-transfer-accumulator-to-stack-633">TCS - Transfer Accumulator to Stack</h4>
<h4 id="tdc-transfer-direct-page-to-accumulator-634">TDC - Transfer Direct Page to Accumulator</h4>
<p>if direct page is 0 then this functions to clear out 16bit A</p>
<pre><code>lda.w #$0000  ;3 bytes, 3 cycles
tdc           ;1 byte, 2 cycles
</code></pre>
<h4 id="tsc-transfer-stack-to-accumulator-640">TSC - Transfer Stack to Accumulator</h4>
<h4 id="tsx-transfer-stack-to-x-641">TSX - Transfer stack to X</h4>
<h4 id="txa-transfer-x-to-accumulator-642">TXA - Transfer X to Accumulator</h4>
<h4 id="txs-transfer-x-to-stack-643">TXS - Transfer X to Stack</h4>
<h4 id="txy-transfer-x-to-y-644">TXY - Transfer X to Y</h4>
<h4 id="tya-transfer-y-to-accumulator-645">TYA - Transfer Y to Accumulator</h4>
<h4 id="tyx-transfer-y-to-x-646">TYX - Transfer Y to X</h4>
<p>Copies the content of one register to another. eg.</p>
<pre><code>A: 0099 X: 1FFF Y:5656 D:0020 S: FFFF    rep #$30
A: 0099 X: 1FFF Y:5656 D:0020 S: FFFF    lda #$0000    ; load A with 0
A: 0000 X: 1FFF Y:5656 D:0020 S: FFFF    tcd           ; transfer A -&gt; D
A: 0000 X: 1FFF Y:5656 D:0000 S: FFFF    txa           ; X -&gt; A
A: 1FFF X: 1FFF Y:5656 D:0000 S: FFFF    tcs           ; A -&gt; S
A: 1FFF X: 1FFF Y:5656 D:0000 S: 1FFF
</code></pre>
<p>You get the idea.</p>
<h4 id="trb-test-and-reset-bit-658">TRB - Test and Reset Bit</h4>
<p>Tests the bit similarly to &quot;AND&quot;, and clears it, while affecting the flags.</p>
<h4 id="tsb-test-and-set-bit-661">TSB - Test and Set Bit</h4>
<p>Tests the bit similarly to &quot;AND&quot;, and sets it, while affecting the flags.</p>
<h4 id="wai-wait-for-interrupt-664">WAI - Wait for Interrupt</h4>
<p>Waits until a hardware interrupt is triggered.</p>
<h4 id="xce-exchange-carry-with-emulation-667">XCE - Exchange Carry with Emulation</h4>
<p>Well, the 65816 has actually 2 modes. Native and (6502) emulation mode. This tutorial deals with native only. The emulation bit shares the same bit as the carry flag so to put ourselves in native mode, we can only set the emulation flag via the carry and exchanging it. For native mode, the emulation flag must be off. To switch to native mode, we must clear the carry and exchange it. eg.</p>
<pre><code>clc
xce
</code></pre>
<p><em>Instruction usage adapted from <a href="/jay's-asm-tutorial">Jay's ASM Tutorial</a></em></p>
<h2 id="datasheets-manuals-etc.-675">Datasheets, Manuals etc.</h2>
<p>Western Design Center Inc. has documentation on the 65816 <a href="http://westerndesigncenter.com/wdc/documentation.cfm" rel="external nofollow noreferrer" target="_blank">here</a>.</p>
<p>Of particular interest would be the <a href="/uploads/assembly-programming-manual-for-w65c816.pdf">assembly-programming-manual-for-w65c816.pdf</a> aka &quot;Programming the 65816 including the 6502, 65C02, and 65802&quot; by David Eyes and Ron Lichty.</p>